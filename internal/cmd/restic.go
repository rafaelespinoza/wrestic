package cmd

import (
	"context"
	"flag"
	"fmt"
	"os"
	"path/filepath"

	"github.com/rafaelespinoza/alf"
	"github.com/rafaelespinoza/wrestic/internal/config"
	"github.com/rafaelespinoza/wrestic/internal/exec"
)

func makeRestic(parentName, name string) alf.Directive {
	fullName := parentName + " " + name

	var params struct {
		configDir     string
		subcmd        string
		storenames    stringList
		destnames     stringList
		baseConfigDir string
		exec          bool
	}

	// Scope this flag set so that the Run function below can access the
	// positional arguments. Those are passed directly to restic.
	flags := flag.NewFlagSet(fullName, flag.ExitOnError)

	return &alf.Command{
		Description: "execute restic subcommands",
		Setup: func(_ flag.FlagSet) *flag.FlagSet {
			flags.StringVar(&params.configDir, "C", defaultConfigDir, "base configuration directory")
			flags.StringVar(&params.subcmd, "c", "", "name of restic subcommand")
			flags.Var(&params.destnames, "destnames", `comma-separated destinations to operate on, example: "list,of,destinations"`)
			flags.Var(&params.storenames, "storenames", `comma-separated storenames to operate on, example: "list,of,stores"`)
			flags.BoolVar(&params.exec, "x", false, "actually execute the commands; if false then preview")

			flags.Usage = func() {
				fmt.Fprintf(flags.Output(), `Usage: %s [flags_for_%s] -- [restic_args_flags]

Description

	Invoke restic subcommands while leveraging authentication mechanisms
	and repository metadata saved in a config file.

	First, this subcommand searches the config file for destinations that match
	the criteria specified in the destnames and storenames flags. Then it loops
	over the results and invokes the specified restic subcommand upon each
	destination.

	Specify restic subcommand with flag -c.
	By default, restic is not actually invoked. Instead, the arguments and flags
	that would be passed to restic are written to stderr as a shell comment.
	To actually run restic, use flag -x.

	The arguments and flag values to pass to the restic subcommand (as in
	[restic_args_flags] in the Usage section above) should be separated
	flags for %s with two dashes:

		%s -storenames foo,bar -destnames bar,foo -c snapshots -- -h
		%s -storenames cha,del -destnames del,cha -c snapshots -- --latest 3

	These restic flags are unnecessary to specify because they are generated by
	this application:
		-r, --repo
		--password-file

	The current configuration directory is:

		%q

Flags:

`, fullName, parentName, parentName, fullName, fullName, params.configDir)
				flags.PrintDefaults()
			}

			return flags
		},
		Run: func(ctx context.Context) error {
			if params.subcmd == "" {
				return fmt.Errorf("subcmd (flag -c) cannot be empty %w", alf.ErrShowUsage)
			}

			if params.configDir == "" {
				return fmt.Errorf("config dir cannot be empty; possibly could not determine a default either %w", alf.ErrShowUsage)
			}

			datastores, err := fetchDatastores(params.configDir, params.storenames.outputs, params.destnames.outputs)
			if err != nil {
				return err
			}

			batch := exec.ResticBatch{
				ConfigDir:  params.configDir,
				Sink:       os.Stderr,
				Subcommand: params.subcmd,
				// Pro tip: ensure that you're passing in the positional arguments
				// of the flag set initialized in this application instead of the
				// args from flag.CommandLine. Lost of bunch of time by looking at
				// the args from the wrong flag set.
				Args:       flags.Args(),
				Run:        params.exec,
				NewCommand: func() exec.Command { return exec.NewRestic(os.Stdout, os.Stderr) },
			}

			return batch.Do(ctx, datastores)
		},
	}
}

func fetchDatastores(configDir string, storenames, destnames []string) (out []config.Datastore, err error) {
	file, err := os.Open(filepath.Clean(filepath.Join(configDir, "datastores.toml")))
	if err != nil {
		return
	}
	defer func() { _ = file.Close() }()

	params, err := config.Parse(file)
	if err != nil {
		return
	}

	out = config.SelectDatastores(params.Datastores, storenames, destnames)
	return
}
